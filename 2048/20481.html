<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="2048.css">

    <title>2048</title>

  </head>
<body>
  <div id="errors" style="
    background: #c00;
    color: #fff;
    display: none;
    margin: -20px -20px 20px;
    padding: 20px;
    white-space: pre-wrap;
  "></div>
  <div id="root"></div>

<script>
  function myFunction(){
    console.log("HELLO");
  }
  window.addEventListener('mousedown', function(e) {
    document.body.classList.add('mouse-navigation');
    document.body.classList.remove('kbd-navigation');
  });
  window.addEventListener('keydown', function(e) {
    if (e.keyCode === 9) {
      document.body.classList.add('kbd-navigation');
      document.body.classList.remove('mouse-navigation');
    }
  });
  window.addEventListener('click', function(e) {
    if (e.target.tagName === 'A' && e.target.getAttribute('href') === '#') {
      e.preventDefault();
    }
  });
  window.onerror = function(message, source, line, col, error) {
    var text = error ? error.stack || error : message + ' (at ' + source + ':' + line + ':' + col + ')';
    errors.textContent += text + '\n';
    errors.style.display = '';
  };
  console.error = (function(old) {
    return function error() {
      errors.textContent += Array.prototype.slice.call(arguments).join(' ') + '\n';
      errors.style.display = '';
      old.apply(this, arguments);
    }
  })(console.error);
</script>


<script type="text/babel">

  function generateNewBoard(){
      var resetBoard = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];

      // create coordinates for random board variables
      var x1 = Math.floor(Math.random() * 3);
      var y1 = Math.floor(Math.random() * 3);

      var x2 = Math.floor(Math.random() * 3);
      var y2 = Math.floor(Math.random() * 3);

      // make sure that the random variables do not clash with each other
      while(x1 == x2 && y1 == y2){
        x2 = Math.floor(Math.random() * 3);
        y2 = Math.floor(Math.random() * 3);
      }

      resetBoard[x1][y1] = 2;
      resetBoard[x2][y2] = 4;

      return resetBoard;
  }

  // check if we already have 2048 on the board - give user the option to continue if 2048
  function is2048(board){
    for(var i = 0; i < 4; i++){
      if(board[i].includes(128)){
        return true;
      }
    }
    return false;
  }

  // returns true if game is over i.e. there are no empty spots or valid moves on the board
  function isGameOver(board){
    // game isn't over while there are still empty fields on the board
    for(var i = 0; i < 4; i++){
      if(board[i].includes(0)){
        return false;
      }
    }
    // game isn't over while the user can still make valid moves
    // check if any horizontal/row valid moves
    for(var row = 0; row < 4; row++){
      for(var num_in_row = 0; num_in_row < 3; num_in_row++){
        if(board[row][num_in_row] == board[row][num_in_row + 1]){
          return false;
        }
      }
    }

    // check if any vertical/column valid moves
    for(var col = 0; col < 4; col++){
      for(var row = 0; row < 3; row++){
        if(board[row][col] == board[row + 1][col]){
          return false;
        }
      }
    }
    // game is over when there are no empty fields/valie moves on the board
    return true;
  }

  function Popup(props){
    return(
      <div className="popup">
        <h1>Game won</h1>
      </div>
    )
  }

  function Square(props){
    var cellName = "general_square square-" + props.value;

    return(
      <div className={cellName}>
        <h1>{props.value}</h1>
      </div>
    );
  }
  class AIagent extends React.Component{
    constructor(props){
      super(props);
      this.state ={
        board: <Board/>,
      }
    }

    render(){
      return(this.state.board);
    };
  }

  class Board extends React.Component{

    constructor(props){
      super(props);
      this.state = {
        score: 0,
        board: generateNewBoard(),
        confirmedContinuePlaying: false,
        playAI: this.props.playAI,
      };
    }

    renderSquare(i, j, counter) {
      //console.log(i, j);
      return (<Square
        value = {this.state.board[i][j]}
        key = {counter}
      />);
    }

    handleClick(name){
      // N.B. use of ... for deep copy
      //var newBoard = [...this.state.board];
      var newBoard = JSON.parse(JSON.stringify(this.state.board));

      if(name=="up"){
        var hullo = this.rotate90(newBoard);
        hullo = this.rotate90(hullo);
        hullo = this.rotate90(hullo);
        newBoard = hullo;
        var [replacementBoard, newScore] = this.moveLeft(newBoard);
        replacementBoard = this.rotate90(replacementBoard);
        //console.log("Move complete");
      }
      if(name=="left"){
        var [replacementBoard, newScore] = this.moveLeft(newBoard);
        //console.log("Move complete");

      }
      else if(name=="right"){
        var hullo = this.rotate90(newBoard);
        hullo = this.rotate90(hullo);
        newBoard = hullo;
        var [replacementBoard, newScore] = this.moveLeft(newBoard);
        replacementBoard = this.rotate90(replacementBoard);
        replacementBoard = this.rotate90(replacementBoard);
        //console.log("Move complete");

      }
      else if(name=="down"){
        // 1, left, 3
        var hullo = this.rotate90(newBoard);
        newBoard = hullo;
        var [replacementBoard, newScore] = this.moveLeft(newBoard);
        replacementBoard = this.rotate90(replacementBoard);
        replacementBoard = this.rotate90(replacementBoard);
        replacementBoard = this.rotate90(replacementBoard);
        //console.log("Move complete");
      }

      // add a random new tile to the board if (i) there are still empty fields on the board AND (ii) the move being made is valid
      if(replacementBoard.some(row => row.includes(0)) && (JSON.stringify(replacementBoard) != JSON.stringify(this.state.board))){

        // generate the position for the random tile
        do {
          var randomX = Math.floor(Math.random() * (3-0+1)) + 0;
          var randomY = Math.floor(Math.random() * (3-0+1)) + 0;
        }
        // ensure the space isn't already taken
        while(replacementBoard[randomX][randomY] != 0)

        // decide - using randomness - whether the new tile will be a 2 or a 4
        var randomnessFactor = Math.random();
        if(randomnessFactor < 0.7){
          replacementBoard[randomX][randomY] = 2;
        }
        else{
          replacementBoard[randomX][randomY] = 4;
        }
      }

      this.setState({
        board: replacementBoard,
        score: this.state.score + newScore,
      });
    }

    rotate90(newBoard){
      var oldArr = newBoard;
      var newArr = [[],[],[],[]];
      var len = newArr.length;

      for(var i=3; i >= 0; i--){
        for(var j=0; j<len; j++){
          newArr[i].push(newBoard[j][i]);
        }
        newArr[i].reverse();
      }

      return newArr;
    }

    moveLeft(newBoard){
      // variable to hold the new board that we're creating
      var refreshedBoard = [];
      var points = 0;

      for(var row in newBoard){
        //var copyRow = [...newBoard[row]];
        var copyRow = newBoard[row];
        // strip out 0s
        var copyRow = copyRow.filter(function check0(num){return num > 0});

        // newRow will be the row with all numbers merged
        var newRow = [];

        //console.log("copyRow is " + copyRow);

        // merge numbers and add 0s as needed
        if(copyRow.length == 0){
          for(var i = 0; i < 4; i++){
            newRow.push(0);
          }
        }
        else if(copyRow.length == 1){
          newRow.push(copyRow[0])
          for(var i = 0; i < 3; i++){
            newRow.push(0);
          }
        }
        else{
          var merged = false;
          for(var i =0; i < copyRow.length; i++){
            // if matching neighbour on right - merge
            if(copyRow[i] == copyRow[i + 1]){
              if(merged == false){
                newRow.push(copyRow[i] + copyRow[i + 1]);
                merged = true;
                points += (copyRow[i] + copyRow[i + 1]);
              }
              else{
                merged = false;
              }
            }
            else if(copyRow[i] > 0){
              if(merged == true){
                merged = false;
              }
              else{
                newRow.push(copyRow[i]);
                merged = false;
              }

            }
            /*/else{
              newRow.push(copyRow[i]);
              merged = false;
            }*/
          }

          var len = newRow.length;

          for(var i = 0; i < 4 - len; i++){
            newRow.push(0);

          }
        }
        refreshedBoard.push(newRow);
      };
      return [refreshedBoard, points];
    }

    // reset board i. .e. clear current board and add random start tiles
    reset(){
      this.setState({
        confirmedContinuePlaying: false,
        board: generateNewBoard(),
        score: 0,
      });
    }

    foo(callback){
      setTimeout(() => {
        console.log("Move left first");
        this.handleClick("left");
        setTimeout(() => {
          this.callback();
        }, 5000)
      }, 5000);
    }

    callback(){
      console.log("Then move down");
      this.handleClick("down");
    }



    // after every move, we check for game over and for game won
    componentDidUpdate(){
        if(isGameOver(this.state.board) == true){
          setTimeout(() => {
            alert("GAME OVER");
            this.reset();
          }, 300);
        }
        else if(is2048(this.state.board) == true && this.state.confirmedContinuePlaying == false){
          setTimeout(() => {
            // if user wants to keep playing, save decision; otherwise finish game
            var contd = confirm("You won! Want to keep playing?");
            if(contd == true){
              this.setState({
                confirmedContinuePlaying: true,
              });
            }
            else{
              // reset the board to a new random start state
              this.reset();
            }
          }, 300);
        }
    }

    componentDidMount() {

      window.addEventListener("keydown", event => {
        // listen for key presses unless the game is over
        if(isGameOver(this.state.board) == false){
          if(event.keyCode === 40){
            this.handleClick("down");
          }
          else if(event.keyCode === 38){
            this.handleClick("up");
          }
          else if(event.keyCode === 37){
            this.handleClick("left");
          }
          else if(event.keyCode === 39){
            this.handleClick("right");
          }
        }
      });

    }

    playAI(){

      setTimeout(() => {
        console.log("Move left first");
        this.handleClick("left");
        setTimeout(() => {
          this.callback();
        }, 50)
      }, 50);
    }


    render(){
      //console.log("Board is re-rendering!")

      var rowsX = []
      var counter = 0
      this.state.board.map((row, i = 0) => {
        var rowX = []
        row.map((row, j = 0) => {
          rowX.push(this.renderSquare(i, j, counter ));
          counter++;
        });
        rowsX.push(
          <div key = {i} className = "board-row">
            {rowX}
          </div>);
        i++;
      });

      return(
        <div>
          <button onClick={() => this.playAI()}>Test Button</button>
          <div>{rowsX}</div>
          <h1>Score: {this.state.score}</h1>
        </div>
      );
      //return rowsX;
    }
  }


  class Child extends React.Component{
    render(){
      return<button onClick={this.props.handler}>Button</button>
    }
  }

  class Game extends React.Component{

    constructor(props){
      super(props);
      this.handler = this.handler.bind(this);

      this.state = {
        playAI: false,
      };
    }

    handler(){
      this.setState({
        playAI: true
      });
    }

    render() {

      var toReturn;

      if(this.state.playAI == false){
        toReturn = <Board/>;
      }
      else{
        toReturn = <AIagent/>;
      }
      console.log(toReturn);

      return(
        <div className="game">
          <div className="testChild">
            <Child handler={this.handler}/>
          </div>
          <div className="game-board">
            {toReturn}
          </div>
        </div>
      );
    }
  }

// ========================================

  ReactDOM.render(<Board />,
  document.getElementById('root')
  );

</script>
</body>
</html>
