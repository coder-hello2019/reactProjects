
<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="2048.css">

    <title>2048</title>

  </head>
<body>
  <div id="errors" style="
    background: #c00;
    color: #fff;
    display: none;
    margin: -20px -20px 20px;
    padding: 20px;
    white-space: pre-wrap;
  "></div>
  <div id="root"></div>

<script>
  function myFunction(){
    console.log("HELLO");
  }
  window.addEventListener('mousedown', function(e) {
    document.body.classList.add('mouse-navigation');
    document.body.classList.remove('kbd-navigation');
  });
  window.addEventListener('keydown', function(e) {
    if (e.keyCode === 9) {
      document.body.classList.add('kbd-navigation');
      document.body.classList.remove('mouse-navigation');
    }
  });
  window.addEventListener('click', function(e) {
    if (e.target.tagName === 'A' && e.target.getAttribute('href') === '#') {
      e.preventDefault();
    }
  });
  window.onerror = function(message, source, line, col, error) {
    var text = error ? error.stack || error : message + ' (at ' + source + ':' + line + ':' + col + ')';
    errors.textContent += text + '\n';
    errors.style.display = '';
  };
  console.error = (function(old) {
    return function error() {
      errors.textContent += Array.prototype.slice.call(arguments).join(' ') + '\n';
      errors.style.display = '';
      old.apply(this, arguments);
    }
  })(console.error);
</script>


<script type="text/babel">

// evaluation function to count
function boardScore(boardState){
  var score = 0;
  for(var i = 0; i < 3; i++){
    for(var j = 0; j < 3; j++){
      score += parseInt(boardState[i][j]);
    }
  }
  // the "up" here is not strictly needed - just matching the format to return a tuple
  return score;
}

/*function countAvailableCells(boardState){
  var count = 0;
  for (var i = 0; i < 4; i++){
    for(var j = 0; j < 4; j++){
      if (boardState[i][j] == 0){
        count += 1;
      }
    }
  }
  return count;
}*/

// the expectimax function to be used in my 2048 AI game
function expectimax(currentPlayer, boardState, currentDepth, currentScore){
  // check if the game is in a terminal state i.e. game over or if we've reached the maximum depth we want to be going to
  /*console.log("We're inside expectimax");
  console.log("Current player: " + currentPlayer);
  console.log("Board state: " + boardState);
  console.log("CurrentDepth: " + currentDepth);*/

  // so we need an evaluation function to look at the state!!!!
  var utility = boardScore(boardState);

  const actions = ["down", "right", "up", "left"];
  var availableActions = [];

  actions.forEach((item, i) => {
    if(isValid(item, boardState)){
      availableActions.push(item);
    }
  });
  //console.log(availableActions);


  if(isGameOver(boardState) == true || (currentDepth == 6)){
    //console.log("currentDepth inside base case: " + currentDepth);
    //console.log(isGameOver(boardState));
    //console.log("The base case has been hit");
    //console.log("Score being returned from the base case: " + currentScore);
    //console.log("The board for which this is the score is: ");
    //console.log(boardState);

    return [currentScore, "left"];
  }

  //else, check if we're currently playing maxPlayer
  else if(currentPlayer == "MAX"){
    var currentDepth = currentDepth + 1;
    //console.log(currentDepth, currentScore);
    //console.log("We're inside MAX");
    var v = -Infinity;
    var bestMove;

    if(currentDepth == 1){
      var originalScore = currentScore;
    }

    var deepCop = JSON.parse(JSON.stringify(boardState));
    var deepCopScore = JSON.parse(JSON.stringify(currentScore));

    // iterate over available actions
    availableActions.forEach(function(item, index){
      //console.log("Back inside MAX");
      //console.log("Now trying move: " + item);

      // simulate making the move i.e. generate the successor state
      var [successorBoard, successorScore] = simulateMove(item, deepCop);

      //console.log("And the successorBoard looks like this: ");
      //console.log(successorBoard);
      //console.log("successorScore: " + successorScore);

      // need to reference the 0th element because expectimax returns a tuple

      //console.log("currentScore being passed to expectimax: " + (deepCopScore + successorScore));
      var expectPoints = expectimax(currentPlayer="RANDOM", boardState=successorBoard, currentDepth = currentDepth, currentScore=deepCopScore + successorScore)[0];
      //console.log("expectPoints being returned to MAX: " + expectPoints);

      //var score = Math.max(v, expectPoints);

      if(expectPoints >= v){
        v = expectPoints;
        bestMove = item;
      }
      //console.log("After the score>v comparison, v and bestMove are (respectively): ");
      //console.log(v, bestMove);


    })
    return [v, bestMove];

  }

  // else check if we're currently playing chance player
  else if(currentPlayer == "RANDOM"){
    //console.log("We're inside RANDOM");

    var boardStateCopy = JSON.parse(JSON.stringify(boardState));

    var currentDepth = currentDepth + 1;

    var v = 0;
    const probDistributionOfActions = {2: 0.6, 4: 0.4}

    // play a random move based on prov distribution of {0.6: 2, 0.4: 4}
    // generate the position for the random tile
    do {
      var randomX = Math.floor(Math.random() * (3-0+1)) + 0;
      var randomY = Math.floor(Math.random() * (3-0+1)) + 0;
    }
    // ensure the space isn't already taken
    while(boardStateCopy[randomX][randomY] != 0)

    // for each available action
    for(var key in probDistributionOfActions){

      var prob = probDistributionOfActions[key];
      var successorBoard = JSON.parse(JSON.stringify(boardStateCopy));


      successorBoard[randomX][randomY] = parseInt(key);

      v += prob * expectimax(currentPlayer="MAX", boardState=successorBoard, currentDepth = currentDepth, currentScore = currentScore)[0];
    //  console.log("V which has been calculated for " + key + "is " + v);
    }
    //console.log("V being returned from RANDOM: ");
    //console.log(v);
    //v = v / 2;
    // returning the "up" here to maintain consistency with the format returned by the "MAX" variation but this won't be getting used anywhere
    // note that we needs to be divided by 2 given that there are 2 possible actions
    return [v, "left"];

  }
  // catch-all in case something goes wrong
  else{
    return None;
  }
}
  function generateNewBoard(){
      /*var resetBoard = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];

      // create coordinates for random board variables
      var x1 = Math.floor(Math.random() * 3);
      var y1 = Math.floor(Math.random() * 3);

      var x2 = Math.floor(Math.random() * 3);
      var y2 = Math.floor(Math.random() * 3);

      // make sure that the random variables do not clash with each other
      while(x1 == x2 && y1 == y2){
        x2 = Math.floor(Math.random() * 3);
        y2 = Math.floor(Math.random() * 3);
      }

      resetBoard[x1][y1] = 2;
      resetBoard[x2][y2] = 4;*/

      var resetBoard = [[0, 2, 0, 0], [0, 0, 0, 0], [4, 0, 0, 0], [0, 0, 0, 0]];

      return resetBoard;
  }

  // check if we already have 2048 on the board - give user the option to continue if 2048
  function is2048(board){
    for(var i = 0; i < 4; i++){
      if(board[i].includes(128)){
        return true;
      }
    }
    return false;
  }

  // returns true if game is over i.e. there are no empty spots or valid moves on the board
  function isGameOver(board){
    // game isn't over while there are still empty fields on the board
    for(var i = 0; i < 4; i++){
      if(board[i].includes(0)){
        return false;
      }
    }
    // game isn't over while the user can still make valid moves
    // check if any horizontal/row valid moves
    for(var row = 0; row < 4; row++){
      for(var num_in_row = 0; num_in_row < 3; num_in_row++){
        if(board[row][num_in_row] == board[row][num_in_row + 1]){
          return false;
        }
      }
    }

    // check if any vertical/column valid moves
    for(var col = 0; col < 4; col++){
      for(var row = 0; row < 3; row++){
        if(board[row][col] == board[row + 1][col]){
          return false;
        }
      }
    }
    // game is over when there are no empty fields/valie moves on the board
    return true;
  }

  function simulateMove(name, newBoard){

    if(name=="up"){
        var hullo = rotate90(newBoard);
        hullo = rotate90(hullo);
        hullo = rotate90(hullo);
        newBoard = hullo;
        var [replacementBoard, newScore] = moveLeft(newBoard);
        replacementBoard = rotate90(replacementBoard);
        //console.log("Move complete");
      }
      if(name=="left"){
        var [replacementBoard, newScore] = moveLeft(newBoard);
        //console.log("Move complete");

      }
      else if(name=="right"){
        var hullo = rotate90(newBoard);
        hullo = rotate90(hullo);
        newBoard = hullo;
        var [replacementBoard, newScore] = moveLeft(newBoard);
        replacementBoard = rotate90(replacementBoard);
        replacementBoard = rotate90(replacementBoard);
        //console.log("Move complete");

      }
      else if(name=="down"){
        // 1, left, 3
        var hullo = rotate90(newBoard);
        newBoard = hullo;
        var [replacementBoard, newScore] = moveLeft(newBoard);
        replacementBoard = rotate90(replacementBoard);
        replacementBoard = rotate90(replacementBoard);
        replacementBoard = rotate90(replacementBoard);
        //console.log("Move complete");
      }
      /*console.log("Board being returned from simulateMove(): ");
      console.log(replacementBoard);
      console.log(JSON.stringify(replacementBoard));*/
      // N.b. not 100% clear why this change needed to be made - random values were being inserted into board

      return[replacementBoard, newScore];
  }


  function rotate90(newBoard){
    var oldArr = newBoard;
    var newArr = [[],[],[],[]];
    var len = newArr.length;

    for(var i=3; i >= 0; i--){
      for(var j=0; j<len; j++){
        newArr[i].push(newBoard[j][i]);
      }
      newArr[i].reverse();
    }
    //console.log("This prints just before the return in rotate90");
    return newArr;
  }

  function moveLeft(newBoard){
    // variable to hold the new board that we're creating
    var refreshedBoard = newBoard;
    var points = 0;

    for(var row in newBoard){
      //var copyRow = [...newBoard[row]];
      var copyRow = newBoard[row];
      // strip out 0s
      var copyRow = copyRow.filter(function check0(num){return num > 0});

      // newRow will be the row with all numbers merged
      var newRow = [];

      // merge numbers and add 0s as needed
      if(copyRow.length == 0){
        for(var i = 0; i < 4; i++){
          newRow.push(0);
        }
      }
      else if(copyRow.length == 1){
        newRow.push(copyRow[0])
        for(var i = 0; i < 3; i++){
          newRow.push(0);
        }
      }
      else{
        var merged = false;
        for(var i =0; i < copyRow.length; i++){
          // if matching neighbour on right - merge
          if(copyRow[i] == copyRow[i + 1]){
            if(merged == false){
              newRow.push(copyRow[i] + copyRow[i + 1]);
              merged = true;
              points += (copyRow[i] + copyRow[i + 1]);
            }
            else{
              merged = false;
            }
          }
          else if(copyRow[i] > 0){
            if(merged == true){
              merged = false;
            }
            else{
              newRow.push(copyRow[i]);
              merged = false;
            }

          }
        }

        var len = newRow.length;

        for(var i = 0; i < 4 - len; i++){
          newRow.push(0);

        }
      }
      refreshedBoard[row] = newRow;

    };

    return [refreshedBoard, points];
  }

  function isValid(name, currentBoard){
    var currentCopied = JSON.parse(JSON.stringify(currentBoard));
    var currentCopied1 = JSON.parse(JSON.stringify(currentBoard));
    var [replacementBoard, newScore] = simulateMove(name, currentCopied1);

    /*console.log("currentBoard: ");
    console.log(currentBoard);

    console.log("currentCopied:");
    console.log(currentCopied);*/

    if(JSON.stringify(replacementBoard) != JSON.stringify(currentCopied)){
      //console.log("Valid")
      return true
    }
    else{
      //console.log("Not valid")
      return false
    }

  }

  function Popup(props){
    return(
      <div className="popup">
        <h1>Game won</h1>
      </div>
    )
  }

  function Square(props){
    var cellName = "general_square square-" + props.value;

    return(
      <div className={cellName}>
        <h1>{props.value}</h1>
      </div>
    );
  }
 /*class AIagent extends React.Component{
    constructor(props){
      super(props);
      this.state ={
        board: <Board/>,
      }
    }
    render(){
      return(this.state.board);
    };
  }*/

  class Board extends React.Component{

    constructor(props){
      super(props);
      this.state = {
        score: 0,
        board: generateNewBoard(),
        confirmedContinuePlaying: false,
        playAI: this.props.playAI,
        AIInterval: this.propsAIInterval
      };
    }

    renderSquare(i, j, counter) {
      return (<Square
        value = {this.state.board[i][j]}
        key = {counter}
      />);
    }

    handleClick(name){
      var currentBoard = JSON.parse(JSON.stringify(this.state.board));
      var copyOfCurrentBoard = JSON.parse(JSON.stringify(currentBoard));

      var [replacementBoard, newScore] = simulateMove(name, currentBoard);

      // add a random new tile to the board if (i) there are still empty fields on the board AND (ii) the move being made is valid

      if(replacementBoard.some(row => row.includes(0)) && (JSON.stringify(replacementBoard) != JSON.stringify(this.state.board))){

        // generate the position for the random tile
        do {
          var randomX = Math.floor(Math.random() * (3-0+1)) + 0;
          var randomY = Math.floor(Math.random() * (3-0+1)) + 0;
        }
        // ensure the space isn't already taken
        while(replacementBoard[randomX][randomY] != 0)

        // decide - using randomness - whether the new tile will be a 2 or a 4
        var randomnessFactor = Math.random();
        if(randomnessFactor < 0.7){
          replacementBoard[randomX][randomY] = 2;
        }
        else{
          replacementBoard[randomX][randomY] = 4;
        }
      }

      this.setState({
        board: replacementBoard,
        score: this.state.score + newScore,
        //score: boardScore(replacementBoard),
      });
    }

      rotate90(newBoard){
      var oldArr = newBoard;
      var newArr = [[],[],[],[]];
      var len = newArr.length;

      for(var i=3; i >= 0; i--){
        for(var j=0; j<len; j++){
          newArr[i].push(newBoard[j][i]);
        }
        newArr[i].reverse();
      }

      return newArr;
    }

    moveLeft(newBoard){
      // variable to hold the new board that we're creating
      var refreshedBoard = [];
      var points = 0;

      for(var row in newBoard){
        //var copyRow = [...newBoard[row]];
        var copyRow = newBoard[row];
        // strip out 0s
        var copyRow = copyRow.filter(function check0(num){return num > 0});

        // newRow will be the row with all numbers merged
        var newRow = [];

        // merge numbers and add 0s as needed
        if(copyRow.length == 0){
          for(var i = 0; i < 4; i++){
            newRow.push(0);
          }
        }
        else if(copyRow.length == 1){
          newRow.push(copyRow[0])
          for(var i = 0; i < 3; i++){
            newRow.push(0);
          }
        }
        else{
          var merged = false;
          for(var i =0; i < copyRow.length; i++){
            // if matching neighbour on right - merge
            if(copyRow[i] == copyRow[i + 1]){
              if(merged == false){
                newRow.push(copyRow[i] + copyRow[i + 1]);
                merged = true;
                points += (copyRow[i] + copyRow[i + 1]);
              }
              else{
                merged = false;
              }
            }
            else if(copyRow[i] > 0){
              if(merged == true){
                merged = false;
              }
              else{
                newRow.push(copyRow[i]);
                merged = false;
              }

            }
          }

          var len = newRow.length;

          for(var i = 0; i < 4 - len; i++){
            newRow.push(0);

          }
        }
        refreshedBoard.push(newRow);
      };
      return [refreshedBoard, points];
    }

    // reset board i. .e. clear current board and add random start tiles
    reset(){
      this.setState({
        confirmedContinuePlaying: false,
        board: generateNewBoard(),
        score: 0,
      });
    }

    foo(callback){
      setTimeout(() => {
        console.log("Move left first");
        this.handleClick("left");
        setTimeout(() => {
          this.callback();
        }, 5000)
      }, 5000);
    }

    callback(){
      console.log("Then move down");
      this.handleClick("down");
    }



    // after every move, we check for game over and for game won
    componentDidUpdate(prevProps, prevState){
        console.log("COMPONENT HAS BEEN UPDATED");

        if(isGameOver(this.state.board) == true){
          console.log("GAME OVER");
          setTimeout(() => {
            alert("GAME OVER");
            this.reset();
          }, 300);
        }
        else if(is2048(this.state.board) == true && this.state.confirmedContinuePlaying == false){
          setTimeout(() => {
            // if user wants to keep playing, save decision; otherwise finish game
            var contd = confirm("You won! Want to keep playing?");
            if(contd == true){
              this.setState({
                confirmedContinuePlaying: true,
              });
            }
            else{
              // reset the board to a new random start state
              this.reset();
            }
          }, 300);
        }
    }

    componentDidMount() {

      window.addEventListener("keydown", event => {
        var copiedBoard = JSON.parse(JSON.stringify(this.state.board));
        // listen for key presses unless the game is over
        if(isGameOver(this.state.board) == false){
          //console.log("copiedBoard inside the if: ");
          //console.log(copiedBoard);
          if(event.keyCode === 40 && isValid("down", copiedBoard)){
            this.handleClick("down");
          }
          else if(event.keyCode === 38 && isValid("up", copiedBoard)){
            this.handleClick("up");
          }
          else if(event.keyCode === 37 && isValid("left", copiedBoard)){
            this.handleClick("left");
          }
          else if(event.keyCode === 39 && isValid("right", copiedBoard)){
            this.handleClick("right");
          }
        }
      });

    }

    playAI(TF){
      console.log("WE'VE JUST ENTERED PLAYAI()");

      if(TF == true){
        clearInterval(this.state.AIInterval);
        return
      }
      else if (typeof this.state.AIInterval !== 'undefined'){
        clearInterval(this.state.AIInterval);
      }

      // this keeps making an AI move every second
    var AIIntervalID = setInterval(() => {

    var boardState = this.state.board;

    //console.log(boardState);

    var bestMove = expectimax("MAX", boardState, 1, this.state.score)[1];
    console.log("bestMove being returned by expectimax: " + bestMove);

     // go ahead and make the move
    this.handleClick(bestMove);

     // check whether latest move has resulted in a game over - if so, break out of this loop
    if(isGameOver(this.state.board)){
      clearInterval(this.state.AIInterval);
    }

  }, 1000 );

    // save the ID of the interval in state so that we can clear it when the user pauses the AI
    this.setState({
      AIInterval: AIIntervalID
    })

      /*var boardCopy = JSON.parse(JSON.stringify(this.state.board));
      const possibleMoves = ["left", "right", "up", "down"];
      var movePoints = {}
      possibleMoves.forEach(function (item, index){
        var [boardieBoard, scorieScore] = simulateMove(item, boardCopy);
        movePoints[item] = scorieScore;
      });
      var highestPossibleScore = 0;
      var bestMove = "left";
      for(var key in movePoints){
        if(movePoints[key] > highestPossibleScore){
          highestPossibleScore = movePoints[key];
          bestMove = key;
        }
      };
      this.handleClick(bestMove);*/

      /*setTimeout(() => {
        console.log("Move left first");
        this.handleClick("left");
        setTimeout(() => {
          this.callback();
        }, 50)
      }, 50);*/
    }


    render(){
      //console.log("Board is re-rendering!")

      var rowsX = []
      var counter = 0
      this.state.board.map((row, i = 0) => {
        var rowX = []
        row.map((row, j = 0) => {
          rowX.push(this.renderSquare(i, j, counter ));
          counter++;
        });
        rowsX.push(
          <div key = {i} className = "board-row">
            {rowX}
          </div>);
        i++;
      });

      return(
        <div>
          <button onClick={() => this.playAI()}>Test Button</button>
          <button onClick={() => this.playAI(true)}>Pause AI</button>
          <div>{rowsX}</div>
          <h1>Score: {this.state.score}</h1>
        </div>
      );
      //return rowsX;
    }
  }


  class Child extends React.Component{
    render(){
      return<button onClick={this.props.handler}>Button</button>
    }
  }

  class Game extends React.Component{

    constructor(props){
      super(props);
      this.handler = this.handler.bind(this);

      this.state = {
        playAI: false,
      };
    }

    handler(){
      this.setState({
        playAI: true
      });
    }

    render() {

      var toReturn;

      toReturn = <Board/>;
      /*if(this.state.playAI == false){
        toReturn = <Board/>;
      }
      else{
        toReturn = <AIagent/>;
      }
      console.log(toReturn);*/

      return(
        <div className="game">
          <div className="testChild">
            <Child handler={this.handler}/>
          </div>
          <div className="game-board">
            {toReturn}
          </div>
        </div>
      );
    }
  }

// ========================================

  ReactDOM.render(<Board />,
  document.getElementById('root')
  );

</script>
</body>
</html>
